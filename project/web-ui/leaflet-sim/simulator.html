<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="./libs/leaflet/leaflet.css"/>
    <link rel="stylesheet" href="./plugins/Coordinates/Leaflet.Coordinates-0.1.3.css"/>
    <link rel="stylesheet" href="./plugins/SimpleGraticule/L.SimpleGraticule.css"/>


    <script src="./libs/leaflet/leaflet.js"></script>
    <script src="./libs/socket.io/socket.io_2.2.0_socket.io.js"></script>
    <script src="./plugins/SimpleGraticule/L.SimpleGraticule.js"></script>
    <script src="./plugins/Coordinates/Leaflet.Coordinates-0.1.3.src.js"></script>
    <script src="./plugins/Realtime/leaflet-realtime.js"></script>
    <script src="./plugins/RotatedMarker/leaflet.rotatedMarker.js"></script>


    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
        }

        .leaflet-grid-label .gridlabel-vert {
            margin-left: 5px;
            -webkit-transform: rotate(90deg);
            transform: rotate(90deg);
        }

        .leaflet-grid-label .gridlabel-vert,
        .leaflet-grid-label .gridlabel-horiz {
            padding-left: 2px;
            font-size: 0.8em;
            text-shadow: -2px 0 #FFFFFF, 0 2px #FFFFFF, 2px 0 #FFFFFF, 0 -2px #FFFFFF;
        }

        .leaflet-container.crosshair-cursor-enabled {
            cursor: crosshair;
        }

    </style>
</head>
<body>
<div id="map"></div>
<script>


    var mapSizeX = 30190;
    var mapSizeY = 10901.944444;


    var minZoom = -5;
    var maxZoom = -1;
    var zoom = -5;
    var img = {width: mapSizeX, height: mapSizeY};

    L.CRS.MySimple = L.extend({}, L.CRS.Simple, {
        //projection: L.Projection.LonLat,
        transformation: new L.Transformation(1, 0, 1, 0)
    });

    var yx = L.latLng;
    var xy = function (x, y) {
        if (L.Util.isArray(x)) { // xy([x, y]);
            return yx(x[1], x[0]);
        }
        return yx(y, x); // xy(x, y);
    };
    var bounds = L.latLngBounds([
        xy(-351.0465117, -468.0620156), // top-left corner
        xy(img.width + 468.0620156, img.height + 643.5852714)       // bottom-right corner
    ]);

    var maxBounds = L.latLngBounds([
        xy(-img.width / 2, -img.height / 2), // top-left corner
        xy(img.width * 1.5, img.height * 1.5)       // bottom-right corner
    ]);

    var map = L.map("map", {
        crs: L.CRS.MySimple,
        center: [0, 0],
        zoom: zoom,
        minZoom: minZoom,
        maxZoom: maxZoom,
        maxBounds: maxBounds
    });

    L.DomUtil.addClass(map._container, 'crosshair-cursor-enabled');


    function layerImage(map) {
        var layerImage = L.imageOverlay('./images/IIoT.png', bounds);
        map.addLayer(layerImage);
        return layerImage;
    }

    // SimpleGraticule
    var gridOptions = {
        interval: 1000,
        showshowOriginLabel: true,
        redraw: 'move'
    };

    /**
     * layer controls
     */
    L.control.layers({}, {
        'Flightpath': layerFlightpath(map),
        'Waypoints': layerWaypoints(map, img),
        'Grid': layerGrid(map),
        'Image': layerImage(map)
    }, {
        collapsed: false
    }).addTo(map);

    /**
     * layer with markers
     */
    function layerWaypoints(map, img) {
        // set marker at the image bound edges
        var layerWaypoints = L.layerGroup([
            L.marker(xy([0, 0])).bindPopup('[0,0]'),
            L.marker(xy(img.width, img.height)).bindPopup(JSON.stringify([img.width, img.height])),
        ]);
        map.addLayer(layerWaypoints);
        return layerWaypoints;
    }

    /**
     * layer with grid
     */
    function layerGrid(map) {
        // set marker at the image bound edges
        var layerBounds = L.layerGroup([
            L.simpleGraticule(gridOptions)
        ]);
        map.addLayer(layerBounds);
        return layerBounds;
    }

    map.on('click', function (event) {
        var coord = event.latlng;
        console.log('X:' + coord.lng + '\nY:' + coord.lat);
        // var marker = L.marker(coord).addTo(layerBounds);
        // marker.bindPopup(coord.toString() + "<br>x: " + coord.lng + "<br>y: " + coord.lat).openPopup()
    });


    /**
     * layer drawing a polyline
     */
    function layerFlightpath(map, rc) {
        let obstacle = [
            {x: 5000, y: 0}, {x: img.width, y: img.height}
        ];
        var points = obstacle.map(function (point) {
            return xy(point.x, point.y)
        });
        var layerFlightpath = L.polyline([points]);
        map.addLayer(layerFlightpath);
        return layerFlightpath;
    }


    L.Control.Coordinates.include({
        _update: function (evt) {
            var pos = evt.latlng,
                opts = this.options;
            if (pos) {
                //pos = pos.wrap(); // Remove that instruction.
                this._currentPos = pos;
                this._inputY.value = L.NumberFormatter.round(pos.lat, opts.decimals, opts.decimalSeperator);
                this._inputX.value = L.NumberFormatter.round(pos.lng, opts.decimals, opts.decimalSeperator);
                this._label.innerHTML = this._createCoordinateLabel(pos);
            }
        }
    });

    L.control.coordinates({
        position: "bottomright",
        decimals: 0, //optional default 4
        decimalSeperator: ".", //optional default "."
        labelTemplateLat: "Y: {y}", //optional default "Lat: {y}"
        labelTemplateLng: "X: {x}", //optional default "Lng: {x}"
        enableUserInput: true, //optional default true
        useDMS: false, //optional default false
        useLatLngOrder: false, //ordering of labels, default false-> lng-lat
        markerType: L.marker, //optional default L.marker
        markerProps: {} //optional default {}
    }).addTo(map);

    var DroneIcon = L.Icon.extend({
        options: {
            iconUrl: './images/drone-large.png',
            iconSize: [48, 48],
            iconAnchor: [24, 24],
            popupAnchor: [0, -24]
        }
    });

    var bigIcon = new DroneIcon({iconUrl: './images/drone-large.png'});
    var smallIcon = new DroneIcon({iconUrl: './images/drone-small.png'});

    var realtime = L.realtime(
        undefined, {
            start: false,
            getFeatureId: function (f) {
                return f.properties.id;
            },
            pointToLayer: function (feature, position) {
                return L.marker(position, {
                    icon: bigIcon,
                    rotationAngle: feature.properties.orientation,
                    draggable: true
                }).bindPopup(
                    '<p>X: ' + feature.geometry.coordinates[0].toString() + '<br />' +
                    '<p>Y: ' + feature.geometry.coordinates[1].toString() + '<br />' +
                    '<p>Z: ' + feature.geometry.coordinates[2].toString() + '<br />' +
                    '<p>Yaw: ' + feature.properties.orientation.toString() + '<br />'
                );
            },
            updateFeature: function (feature, oldLayer, newLayer) {
                if (!newLayer) {
                    return;
                }
                // update properties
                newLayer.setRotationAngle(feature.properties.orientation);
                return L.Realtime.prototype.options.updateFeature(feature, oldLayer);
            }

        }
    ).addTo(map);

    var socket = io.connect('http://localhost:3000/red/ws/data');
    socket.on('update', function (data) {
        var myData = JSON.parse(data);
        for (let i = 0; i < myData.features.length; i++) {
            realtime.update(myData.features[i]);
        }
    });

</script>
</body>

</html>
